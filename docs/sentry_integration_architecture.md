# Sentry Error Reporting Integration\n\n**Date**: June 12, 2025  \n**Status**: Implemented  \n**Decision Makers**: Daniel (Platform Developer)\n\n## Context\n\nAs the Puzzle Bazaar app moves toward production, we needed a way to track crashes and errors that occur on real devices in the wild. While our privacy-first approach and clean architecture are important, having visibility into production issues is crucial for maintaining app quality and user experience.\n\nAfter evaluating Firebase vs Sentry, we chose Sentry for its:\n- Minimal architecture impact\n- Privacy-conscious design\n- Focused error tracking capabilities\n- Gentle learning curve\n- Alignment with our small studio needs\n\n## Decision\n\nWe integrated Sentry Flutter SDK at the free tier level (5,000 errors/month) with a privacy-conscious configuration that maintains our existing architectural principles.\n\n## Implementation Details\n\n### Architecture Integration\n\n#### Error Reporting Service Interface\nCreated `ErrorReportingService` abstract interface in `lib/core/domain/services/error_reporting_service.dart` to maintain hexagonal architecture principles:\n\n```dart\nabstract class ErrorReportingService {\n  Future<void> initialize();\n  Future<void> reportException(dynamic exception, {/* context params */});\n  Future<void> reportMessage(String message, {/* optional params */});\n  Future<void> addBreadcrumb(String message, {/* context data */});\n  // ... other methods\n}\n```\n\n#### Sentry Implementation\nImplemented `SentryErrorReportingService` in `lib/core/infrastructure/sentry_error_reporting_service.dart` with:\n- Privacy-first configuration (no PII collection)\n- Smart event filtering to reduce noise\n- Contextual breadcrumbs for debugging\n- Performance monitoring (10% sampling)\n- Environment-aware settings\n\n#### Service Locator Integration\nRegistered error reporting service in dependency injection:\n```dart\nvoid setupDependencies() {\n  serviceLocator.registerSingleton<ErrorReportingService>(SentryErrorReportingService());\n  // ... other services\n}\n```\n\n### Integration Points\n\n#### App Initialization\n- Added error reporting initialization to `AppInitializer`\n- Breadcrumb tracking for app lifecycle events\n- Error reporting for critical initialization failures\n\n#### Game Module Integration\n- Error tracking in `PuzzleGameModule.startGame()` with detailed context\n- Breadcrumbs for game lifecycle events (start, complete, etc.)\n- Exception reporting with puzzle-specific metadata\n\n#### UI Integration\n- Enhanced error handling in `EnhancedPuzzleGameWidget`\n- User action tracking via breadcrumbs\n- Graceful error recovery with user-friendly messages\n\n#### Main App Integration\n- Sentry Flutter wrapper around main app initialization\n- Automatic Flutter error capture integration\n\n### Privacy Configuration\n\n#### Data Collection Limits\n```dart\noptions.sendDefaultPii = false; // No personally identifiable info\noptions.attachViewHierarchy = false; // Don't send UI hierarchy\noptions.beforeSend = _filterEvent; // Custom event filtering\n```\n\n#### Smart Filtering\n- Filters out debug-mode noise\n- Excludes network connectivity issues\n- Removes non-actionable exceptions\n- Scrubs file paths to prevent user info leakage\n\n#### Contextual Data\n- Game session IDs (anonymous)\n- Puzzle difficulty and grid size\n- App version and platform info\n- User actions via breadcrumbs\n- Performance metrics (10% sampling)\n\n## Configuration Requirements\n\n### Sentry DSN Setup\n1. Create Sentry account at https://sentry.io\n2. Create new Flutter project\n3. Get DSN from project settings\n4. Replace placeholder DSN in `SentryErrorReportingService._getDsn()`\n\n### Environment Configuration\n```dart\n// Production DSN (replace with actual)\nconst dsn = String.fromEnvironment(\n  'SENTRY_DSN',\n  defaultValue: 'https://your-actual-dsn@sentry.io/your-project-id',\n);\n```\n\n### Build Configuration\nNo additional build configuration required - Sentry Flutter handles setup automatically.\n\n## Benefits Realized\n\n### Development Benefits\n- **Production Visibility**: Real crash reports from user devices\n- **Context-Rich Debugging**: Breadcrumbs show user actions leading to errors\n- **Performance Insights**: App startup times and frame rates\n- **Release Tracking**: Errors correlated with app versions\n\n### User Experience Benefits\n- **Proactive Issue Resolution**: Fix crashes before users report them\n- **Improved Stability**: Data-driven bug prioritization\n- **Faster Support**: Detailed crash context for user issues\n\n### Architecture Benefits\n- **Clean Integration**: No pollution of existing hexagonal architecture\n- **Testable**: Error reporting service can be mocked for tests\n- **Swappable**: Can easily replace with different provider later\n- **Optional**: App works fine if error reporting fails\n\n## Implementation Footprint\n\n### Dependencies Added\n```yaml\ndependencies:\n  sentry_flutter: ^7.18.0  # ~2MB APK size increase\n```\n\n### Code Changes\n- **New Files**: 2 (interface + implementation)\n- **Modified Files**: 4 (service locator, app initializer, main.dart, game module)\n- **Lines of Code**: ~400 lines total\n- **Architecture Impact**: Minimal - maintained clean separation\n\n### Performance Impact\n- **App Startup**: <50ms additional initialization time\n- **Runtime Overhead**: Negligible for error-free operations\n- **Memory Usage**: ~1-2MB additional memory footprint\n- **Network**: Only on errors/performance events (configurable sampling)\n\n## Usage Examples\n\n### Automatic Error Capture\n```dart\n// Uncaught exceptions automatically reported with context\ntry {\n  await gameSession.initializePuzzle();\n} catch (e, stackTrace) {\n  // Automatic reporting + custom context\n  await errorReporting.reportException(e, \n    stackTrace: stackTrace,\n    context: 'puzzle_initialization',\n    extra: {'puzzle_id': puzzleId, 'grid_size': gridSize},\n  );\n  rethrow;\n}\n```\n\n### User Action Tracking\n```dart\n// Track user actions for debugging context\nawait errorReporting.addBreadcrumb(\n  'Piece placed successfully',\n  category: 'game_action',\n  data: {\n    'piece_id': piece.id,\n    'pieces_remaining': piecesRemaining,\n  },\n);\n```\n\n### Performance Monitoring\n```dart\n// Track performance-critical operations\nfinal transaction = await errorReporting.startTransaction(\n  'puzzle_load', 'asset_loading'\n);\ntry {\n  await loadPuzzleAssets();\n} finally {\n  await transaction?.finish();\n}\n```\n\n## Privacy Policy Impact\n\n### Required Updates\nOur privacy policy needs updates to reflect error reporting:\n\n1. **Data Collection Section**: Add crash reporting disclosure\n2. **Data Usage Section**: Explain crash data helps improve app stability\n3. **Third Party Services**: Mention Sentry as error tracking provider\n4. **Data Retention**: Sentry's data retention policy (90 days default)\n\n### Minimal Privacy Impact\n- No personal information collected\n- Anonymous session identifiers only\n- No device identifiers or user tracking\n- Focus on technical crash data only\n\n## Monitoring and Maintenance\n\n### Sentry Dashboard\n- **Issues Tab**: View crashes grouped by similarity\n- **Performance Tab**: Monitor app performance metrics\n- **Releases Tab**: Track issues by app version\n- **Alerts Tab**: Configure notifications for critical issues\n\n### Regular Maintenance\n- **Weekly**: Review new issues and prioritize fixes\n- **Monthly**: Analyze performance trends and optimize\n- **Per Release**: Tag releases for issue correlation\n- **Quarterly**: Review error filtering rules and adjust\n\n### Alert Configuration\n- **Critical Errors**: Immediate notification (>10 users affected)\n- **Performance Degradation**: Daily digest for slow operations\n- **New Issues**: Weekly summary of first-time errors\n- **Volume Spikes**: Alert if error rate increases 2x\n\n## Testing Strategy\n\n### Development Testing\n```dart\n// Test error reporting in development\nif (kDebugMode) {\n  await errorReporting.reportMessage(\n    'Test error reporting setup',\n    level: 'info',\n    tags: {'test': 'true'},\n  );\n}\n```\n\n### Integration Testing\n- Mock `ErrorReportingService` in widget tests\n- Verify error handling doesn't break app flow\n- Test graceful degradation when reporting fails\n\n### Production Validation\n- Monitor Sentry dashboard after deployment\n- Verify real crashes are being captured\n- Confirm filtering rules work as expected\n\n## Rollback Plan\n\nIf issues arise with Sentry integration:\n\n1. **Immediate**: Disable error reporting via feature flag\n```dart\noptions.dsn = ''; // Disables Sentry\n```\n\n2. **Short-term**: Remove Sentry wrapper from main.dart\n3. **Long-term**: Remove dependency and service implementation\n\n## Future Enhancements\n\n### When Ready for Expansion\n1. **Custom User Context**: Anonymous user IDs for session tracking\n2. **Advanced Filtering**: Machine learning-based noise reduction\n3. **Performance Monitoring**: Detailed frame rate and memory tracking\n4. **Release Health**: Crash-free session rate monitoring\n5. **Custom Dashboards**: Game-specific metrics and visualizations\n\n### Potential Integrations\n1. **CI/CD Integration**: Automatic release notifications\n2. **Issue Tracking**: Link Sentry issues to GitHub/Jira tickets\n3. **Slack Notifications**: Team alerts for critical issues\n4. **Custom Metrics**: Game-specific performance indicators\n\n## Success Metrics\n\n### Short-term (1-3 months)\n- **Issue Discovery**: Identify 5+ production issues not caught in testing\n- **Resolution Time**: Reduce crash debugging time by 50%\n- **User Impact**: Decrease crash-related 1-star reviews\n\n### Long-term (6+ months)\n- **App Stability**: Increase crash-free session rate to >99.5%\n- **Performance**: Identify and fix performance bottlenecks\n- **User Satisfaction**: Correlate stability improvements with ratings\n\n## Conclusion\n\nSentry integration provides production visibility while maintaining our privacy-first approach and clean architecture. The implementation is minimal, focused, and provides immediate value for debugging production issues.\n\nThe free tier (5,000 errors/month) should be sufficient for our current user base, and we can upgrade if needed as we scale. The implementation allows easy removal or replacement if requirements change.\n\nThis foundation gives us confidence in production deployments while maintaining the architectural quality and privacy principles that define our app.\n