// Accessible Tray Scroll Wheel Widget
// File: lib/game_module/widgets/tray_scroll_wheel.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'dart:math' as math;

/// Accessible scroll wheel for pieces tray navigation
/// Designed for users with low vision and motor difficulties
class TrayScrollWheel extends StatefulWidget {
  const TrayScrollWheel({
    super.key,
    required this.scrollController,
    required this.itemCount,
    required this.visibleItemCount,
    this.wheelSize = 60.0,
    this.onScrollChanged,
  });

  final ScrollController scrollController;
  final int itemCount;
  final int visibleItemCount;
  final double wheelSize;
  final VoidCallback? onScrollChanged;

  @override
  State<TrayScrollWheel> createState() => _TrayScrollWheelState();
}

class _TrayScrollWheelState extends State<TrayScrollWheel>
    with TickerProviderStateMixin {
  late AnimationController _rotationController;
  late AnimationController _highlightController;
  
  double _currentRotation = 0.0;
  double _lastPanAngle = 0.0;
  bool _isInteracting = false;
  
  // Accessibility and motor control settings
  static const double _rotationSensitivity = 0.5; // Slower rotation for precision
  static const double _snapThreshold = 0.1; // Snap to positions for stability
  static const int _hapticFeedbackInterval = 10; // Haptic every N degrees
  
  @override
  void initState() {
    super.initState();
    
    _rotationController = AnimationController(
      duration: const Duration(milliseconds: 200),
      vsync: this,
    );
    
    _highlightController = AnimationController(
      duration: const Duration(milliseconds: 150),
      vsync: this,
    );
  }
  
  @override
  void dispose() {
    _rotationController.dispose();
    _highlightController.dispose();
    super.dispose();
  }
  
  @override
  Widget build(BuildContext context) {
    // Don't show wheel if all items are visible
    if (widget.itemCount <= widget.visibleItemCount) {
      return const SizedBox.shrink();
    }
    
    return Container(
      width: widget.wheelSize,
      height: widget.wheelSize,
      margin: const EdgeInsets.symmetric(vertical: 8),
      child: Stack(
        alignment: Alignment.center,
        children: [
          // Background circle with high contrast
          _buildWheelBackground(),
          
          // Rotatable wheel with tick marks
          _buildRotatableWheel(),
          
          // Center indicator
          _buildCenterIndicator(),
          
          // Touch/drag detector
          _buildGestureDetector(),
          
          // Accessibility label
          _buildAccessibilityLabel(),
        ],
      ),
    );
  }
  
  Widget _buildWheelBackground() {
    return AnimatedBuilder(
      animation: _highlightController,
      builder: (context, child) {
        final highlightValue = _highlightController.value;
        return Container(
          width: widget.wheelSize,
          height: widget.wheelSize,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            color: Colors.white,
            border: Border.all(
              color: Color.lerp(
                Colors.grey[400]!,
                Colors.blue[600]!,
                highlightValue,
              )!,
              width: 3 + (highlightValue * 2), // Thicker when active
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.1 + (highlightValue * 0.1)),
                blurRadius: 4 + (highlightValue * 4),
                offset: const Offset(0, 2),
              ),
            ],
          ),
        );
      },
    );
  }
  
  Widget _buildRotatableWheel() {
    return AnimatedBuilder(
      animation: _rotationController,
      builder: (context, child) {
        return Transform.rotate(
          angle: _currentRotation,
          child: SizedBox(
            width: widget.wheelSize,
            height: widget.wheelSize,
            child: CustomPaint(
              painter: _WheelTickPainter(
                isInteracting: _isInteracting,
                highlightValue: _highlightController.value,
              ),
            ),
          ),
        );
      },
    );
  }
  
  Widget _buildCenterIndicator() {
    return AnimatedBuilder(
      animation: _highlightController,
      builder: (context, child) {
        final highlightValue = _highlightController.value;
        return Container(
          width: 12 + (highlightValue * 4),
          height: 12 + (highlightValue * 4),
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            color: Color.lerp(
              Colors.grey[600]!,
              Colors.blue[700]!,
              highlightValue,
            ),
            boxShadow: [
              if (highlightValue > 0)
                BoxShadow(
                  color: Colors.blue.withOpacity(0.3 * highlightValue),
                  blurRadius: 6 * highlightValue,
                  spreadRadius: 2 * highlightValue,
                ),
            ],
          ),
        );
      },
    );
  }
  
  Widget _buildGestureDetector() {
    return GestureDetector(
      onPanStart: _onPanStart,
      onPanUpdate: _onPanUpdate,
      onPanEnd: _onPanEnd,
      onTap: _onTap,
      child: Container(
        width: widget.wheelSize,
        height: widget.wheelSize,
        decoration: const BoxDecoration(
          shape: BoxShape.circle,
          color: Colors.transparent,
        ),
      ),
    );
  }
  
  Widget _buildAccessibilityLabel() {
    return Semantics(
      label: 'Scroll wheel for pieces tray',
      hint: 'Drag in a circle to scroll through puzzle pieces',
      value: _getScrollPosition(),
      onIncrease: _scrollDown,
      onDecrease: _scrollUp,
      child: const SizedBox(),
    );
  }
  
  void _onPanStart(DragStartDetails details) {
    _isInteracting = true;
    _highlightController.forward();
    
    final center = Offset(widget.wheelSize / 2, widget.wheelSize / 2);
    final offset = details.localPosition - center;
    _lastPanAngle = math.atan2(offset.dy, offset.dx);
    
    // Haptic feedback for interaction start
    HapticFeedback.lightImpact();
  }
  
  void _onPanUpdate(DragUpdateDetails details) {
    final center = Offset(widget.wheelSize / 2, widget.wheelSize / 2);
    final offset = details.localPosition - center;
    final currentAngle = math.atan2(offset.dy, offset.dx);
    
    // Calculate angle difference with wrap-around handling
    double angleDiff = currentAngle - _lastPanAngle;
    if (angleDiff > math.pi) angleDiff -= 2 * math.pi;
    if (angleDiff < -math.pi) angleDiff += 2 * math.pi;
    
    // Apply rotation with reduced sensitivity for precision
    final rotationDelta = angleDiff * _rotationSensitivity;
    _currentRotation += rotationDelta;
    _lastPanAngle = currentAngle;
    
    // Convert rotation to scroll position
    _updateScrollFromRotation(rotationDelta);
    
    // Haptic feedback for smooth scrolling
    if ((_currentRotation % (math.pi / _hapticFeedbackInterval)).abs() < 0.1) {
      HapticFeedback.selectionClick();
    }
    
    setState(() {});
    widget.onScrollChanged?.call();
  }
  
  void _onPanEnd(DragEndDetails details) {
    _isInteracting = false;
    _highlightController.reverse();
    
    // Snap to nearest position for stability
    _snapToNearestPosition();
    
    // Final haptic feedback
    HapticFeedback.mediumImpact();
  }
  
  void _onTap() {
    // Provide alternative tap interaction for users who can't drag
    HapticFeedback.lightImpact();
    
    // Scroll down by one item
    _scrollDown();
  }
  
  void _updateScrollFromRotation(double rotationDelta) {
    if (!widget.scrollController.hasClients) return;
    
    // Calculate scroll amount based on rotation
    final maxScrollExtent = widget.scrollController.position.maxScrollExtent;
    final scrollDelta = (rotationDelta / (2 * math.pi)) * maxScrollExtent * 0.1;
    
    final currentOffset = widget.scrollController.offset;
    final newOffset = (currentOffset + scrollDelta).clamp(0.0, maxScrollExtent);
    
    widget.scrollController.jumpTo(newOffset);
  }
  
  void _snapToNearestPosition() {
    // Snap rotation to nearest 15-degree increment for stability
    const snapIncrement = math.pi / 12; // 15 degrees
    final snappedRotation = ((_currentRotation / snapIncrement).round()) * snapIncrement;
    
    if ((snappedRotation - _currentRotation).abs() < _snapThreshold) {
      _currentRotation = snappedRotation;
      _rotationController.reset();
      _rotationController.forward();
    }
  }
  
  String _getScrollPosition() {
    if (!widget.scrollController.hasClients) return 'Beginning';
    
    final maxScroll = widget.scrollController.position.maxScrollExtent;
    final currentScroll = widget.scrollController.offset;
    
    if (maxScroll == 0) return 'All items visible';
    
    final percentage = ((currentScroll / maxScroll) * 100).round();
    return 'Scrolled $percentage%';
  }
  
  void _scrollUp() {
    if (!widget.scrollController.hasClients) return;
    
    const scrollAmount = 50.0;
    final currentOffset = widget.scrollController.offset;
    final newOffset = math.max(0.0, currentOffset - scrollAmount);
    
    widget.scrollController.animateTo(
      newOffset,
      duration: const Duration(milliseconds: 200),
      curve: Curves.easeOut,
    );
    
    HapticFeedback.selectionClick();
    widget.onScrollChanged?.call();
  }
  
  void _scrollDown() {
    if (!widget.scrollController.hasClients) return;
    
    const scrollAmount = 50.0;
    final maxScrollExtent = widget.scrollController.position.maxScrollExtent;
    final currentOffset = widget.scrollController.offset;
    final newOffset = math.min(maxScrollExtent, currentOffset + scrollAmount);
    
    widget.scrollController.animateTo(
      newOffset,
      duration: const Duration(milliseconds: 200),
      curve: Curves.easeOut,
    );
    
    HapticFeedback.selectionClick();
    widget.onScrollChanged?.call();
  }
}

/// Custom painter for wheel tick marks and visual feedback
class _WheelTickPainter extends CustomPainter {
  const _WheelTickPainter({
    required this.isInteracting,
    required this.highlightValue,
  });
  
  final bool isInteracting;
  final double highlightValue;
  
  @override
  void paint(Canvas canvas, Size size) {
    final center = Offset(size.width / 2, size.height / 2);
    final radius = size.width / 2;
    
    // Draw tick marks around the perimeter
    const tickCount = 24; // Every 15 degrees
    const majorTickInterval = 4; // Every 60 degrees
    
    for (int i = 0; i < tickCount; i++) {
      final angle = (i / tickCount) * 2 * math.pi;
      final isMajorTick = i % majorTickInterval == 0;
      
      final tickLength = isMajorTick ? 8.0 : 4.0;
      final tickWidth = isMajorTick ? 2.0 : 1.0;
      
      final innerRadius = radius - tickLength;
      final outerRadius = radius - 2;
      
      final startX = center.dx + innerRadius * math.cos(angle);
      final startY = center.dy + innerRadius * math.sin(angle);
      final endX = center.dx + outerRadius * math.cos(angle);
      final endY = center.dy + outerRadius * math.sin(angle);
      
      final paint = Paint()
        ..color = Color.lerp(
          Colors.grey[600]!,
          Colors.blue[700]!,
          highlightValue,
        )!
        ..strokeWidth = tickWidth + (highlightValue * 1)
        ..strokeCap = StrokeCap.round;
      
      canvas.drawLine(
        Offset(startX, startY),
        Offset(endX, endY),
        paint,
      );
    }
    
    // Draw direction arrows for major ticks if interacting
    if (isInteracting && highlightValue > 0.5) {
      _drawDirectionArrows(canvas, center, radius, highlightValue);
    }
  }
  
  void _drawDirectionArrows(Canvas canvas, Offset center, double radius, double highlightValue) {
    final arrowPaint = Paint()
      ..color = Colors.blue[600]!.withOpacity(0.6 * highlightValue)
      ..strokeWidth = 2.0
      ..strokeCap = StrokeCap.round
      ..style = PaintingStyle.stroke;
    
    // Draw subtle directional indicators at top and bottom
    const arrowSize = 6.0;
    
    // Top arrow (scroll up)
    final topCenter = Offset(center.dx, center.dy - radius + 15);
    final topArrow = Path()
      ..moveTo(topCenter.dx - arrowSize, topCenter.dy + arrowSize)
      ..lineTo(topCenter.dx, topCenter.dy)
      ..lineTo(topCenter.dx + arrowSize, topCenter.dy + arrowSize);
    
    // Bottom arrow (scroll down)  
    final bottomCenter = Offset(center.dx, center.dy + radius - 15);
    final bottomArrow = Path()
      ..moveTo(bottomCenter.dx - arrowSize, bottomCenter.dy - arrowSize)
      ..lineTo(bottomCenter.dx, bottomCenter.dy)
      ..lineTo(bottomCenter.dx + arrowSize, bottomCenter.dy - arrowSize);
    
    canvas.drawPath(topArrow, arrowPaint);
    canvas.drawPath(bottomArrow, arrowPaint);
  }
  
  @override
  bool shouldRepaint(covariant _WheelTickPainter oldDelegate) {
    return oldDelegate.isInteracting != isInteracting ||
           oldDelegate.highlightValue != highlightValue;
  }
}
